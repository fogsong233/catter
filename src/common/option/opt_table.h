#pragma once

#include "parsed_arg.h"
#include "opt_specifier.h"
#include <cassert>
#include <expected>
#include <functional>
#include <set>
#include <span>
#include <string>
#include <string_view>
#include <vector>

namespace catter::opt {

class Option;

/// Helper for overload resolution while transitioning from
/// FlagsToInclude/FlagsToExclude APIs to VisibilityMask APIs.
class Visibility {
    unsigned mask = ~0U;

public:
    explicit Visibility(unsigned mask) : mask(mask) {}

    Visibility() = default;

    operator unsigned() const {
        return this->mask;
    }
};

/// Provide access to the Option info table.
///
/// The OptTable class provides a layer of indirection which allows Option
/// instance to be created lazily. In the common case, only a few options will
/// be needed at runtime; the OptTable class maintains enough information to
/// parse command lines without instantiating Options, while letting other
/// parts of the driver still use Option instances where convenient.
class OptTable {
public:
    //   /// Represents a subcommand and its options in the option table.
    //   struct SubCommand {
    //     const char *Name;
    //     const char *HelpText;
    //     const char *Usage;
    //   };

    /// Entry for a single option instance in the option data table.
    /// It is static data generated by TableGen.
    struct Info {
        std::span<const std::string_view> _prefixes;
        std::string_view _prefixed_name;
        unsigned id;
        unsigned char kind;
        unsigned short group_id;
        unsigned short alias_id;
        const char* alias_args;
        unsigned int flags;
        unsigned int visibility;
        unsigned char param;
        const char* help_text;
        // Help text for specific visibilities. A list of pairs, where each pair
        // is a list of visibilities and a specific help string for those
        // visibilities. If no help text is found in this list for the visibility of
        // the program, HelpText is used instead. This cannot use std::vector
        // because OptTable is used in constexpr contexts. Increase the array sizes
        // here if you need more entries and adjust the constants in
        // OptionParserEmitter::EmitHelpTextsForVariants.
        // In short, print different help text for different visibility levels.
        // do not use in catter
        std::array<std::pair<std::array<unsigned int, 2 /*MaxVisibilityPerHelp*/>, const char*>,
                   1 /*MaxVisibilityHelp*/>
            help_texts_for_variants;
        // placeholder for meta variable name.
        // eg. FILENAME for --output=FILENAME
        const char* meta_var;

        // std::vector<unsigned> SubCommandIndexes;

        bool has_no_prefix() const {
            return this->_prefixes.size() == 0;
        }

        unsigned num_prefixes() const {
            return this->_prefixes.size();
        }

        std::span<const std::string_view> prefixes() const {
            return this->_prefixes;
        }

        /// llvm recent add it, but catter do not use it now
        // bool hasSubCommands() const { return this->SubCommandIndexes.size() != 0;
        // }

        // std::span<const unsigned> getSubCommandIndexes() const {
        //   return std::span(this->SubCommandIndexes);
        // }

        std::string_view prefixed_name() const {
            return this->_prefixed_name;
        }

        std::string_view name() const {
            unsigned prefix_length = this->has_no_prefix() ? 0 : this->_prefixes[0].size();
            return this->_prefixed_name.substr(prefix_length);
        }
    };

public:
    //   bool isValidForSubCommand(const Info *CandidateInfo,
    //                             std::string_view SubCommand) const {
    //     assert(!SubCommand.empty() &&
    //            "This helper is only for valid registered subcommands.");
    //     auto SCIT =
    //         std::find_if(this->SubCommands.begin(), this->SubCommands.end(),
    //                      [&](const auto &C) { return SubCommand == C.Name; });
    //     assert(SCIT != SubCommands.end() &&
    //            "This helper is only for valid registered subcommands.");
    //     auto SearchRes = std::find_if(
    //         CandidateInfo->getSubCommandIndexes().begin(),
    //         CandidateInfo->getSubCommandIndexes().end(), [&](unsigned Idx) {
    //           return this->SubCommands[Idx].Name == SubCommand;
    //         });
    //     return SearchRes != CandidateInfo->getSubCommandIndexes().end();
    //   }

private:
    /// The option information table.
    std::span<const Info> option_infos;

    bool ignore_case;

    /// The subcommand information table.
    //   std::span<SubCommand> SubCommands;

    bool grouped_short_options = false;
    bool dash_dash_parsing = false;
    const char* env_var = nullptr;

    unsigned input_option_id = 0;
    unsigned unknown_option_id = 0;

protected:
    /// The index of the first option which can be parsed (i.e., is not a
    /// special option like 'input' or 'unknown', and is not an option group).
    unsigned first_searchable_index = 0;

    /// The union of all option prefixes. If an argument does not begin with
    /// one of these, it is an input.
    std::vector<std::string_view> _prefixes_union;

    /// The union of the first element of all option prefixes.
    std::vector<char> prefix_chars;

private:
    const Info& info(OptSpecifier opt) const {
        unsigned id = opt.id();
        assert(id > 0 && id - 1 < this->num_options() && "Invalid Option ID.");
        return this->option_infos[id - 1];
    }

public:
    OptTable(std::span<const OptTable::Info> option_infos,
             bool ignore_case,
             //    std::span<SubCommand> SubCommands = {},
             std::vector<std::string_view> prefixes_union = {});

    /// Build (or rebuild) the PrefixChars member.
    void buildPrefixChars() {
        assert(this->prefix_chars.empty() && "rebuilding a non-empty prefix char");
        std::set<char> seen_chars;

        // Build prefix chars.
        for(auto& prefix: this->_prefixes_union) {
            seen_chars.insert(prefix.begin(), prefix.end());
        }
        this->prefix_chars.assign(seen_chars.begin(), seen_chars.end());
    }

public:
    virtual ~OptTable() = default;

    //   std::span<SubCommand> getSubCommands() const { return SubCommands; }

    /// Return the total number of option classes.
    unsigned num_options() const {
        return this->option_infos.size();
    }

    auto options() const {
        return this->option_infos;
    }

    /// Get the given Opt's Option instance, lazily creating it
    /// if necessary.
    ///
    /// \return The option, or null for the INVALID option id.
    const Option option(OptSpecifier opt) const;

    /// Lookup the name of the given option.
    std::string_view option_name(OptSpecifier id) const {
        return this->info(id).name();
    }

    /// Lookup the prefix of the given option.
    const std::string_view option_prefix(OptSpecifier id) const {
        const Info& i = this->info(id);
        return i.has_no_prefix() ? "" : i.prefixes()[0];
    }

    std::string_view option_prefixed_name(OptSpecifier id) const {
        return this->info(id).prefixed_name();
    }

    /// Get the kind of the given option.
    unsigned option_kind(OptSpecifier id) const {
        return this->info(id).kind;
    }

    /// Get the group id for the given option.
    unsigned option_group_id(OptSpecifier id) const {
        return this->info(id).group_id;
    }

    /// Get the help text to use to describe this option.
    const char* option_help_text(OptSpecifier id) const {
        return this->option_help_text(id, Visibility(0));
    }

    // Get the help text to use to describe this option.
    // If it has visibility specific help text and that visibility is in the
    // visibility mask, use that text instead of the generic text.
    const char* option_help_text(OptSpecifier id, Visibility visibility_mask) const {
        auto info = this->info(id);
        for(auto [visibilities, text]: info.help_texts_for_variants)
            for(auto visibility: visibilities)
                if(visibility_mask & visibility)
                    return text;
        return info.help_text;
    }

    /// Get the meta-variable name to use when describing
    /// this options values in the help text.
    const char* option_meta_var(OptSpecifier id) const {
        return this->info(id).meta_var;
    }

    /// Specify the environment variable where initial options should be read.
    void set_initial_options_from_environment(const char* e) {
        this->env_var = e;
    }

    /// Support grouped short options. e.g. -ab represents -a -b.
    void set_grouped_short_options(bool value) {
        this->grouped_short_options = value;
    }

    /// Set whether "--" stops option parsing and treats all subsequent
    /// arguments as positional. E.g. -- -a -b gives two positional inputs.
    void set_dash_dash_parsing(bool value) {
        this->dash_dash_parsing = value;
    }

    std::span<const std::string_view> prefixes_union() const {
        return std::span(this->_prefixes_union);
    }

    using InputArgVec = std::vector<std::string>;

public:
    std::optional<opt::ParsedArgument> parse_one_arg_grouped(InputArgVec& argv,
                                                             unsigned& index) const;

    std::optional<ParsedArgument> parse_one_arg(InputArgVec& argv,
                                                unsigned& index,
                                                Visibility visibility_mask = Visibility()) const;

    std::optional<ParsedArgument> parse_one_arg(InputArgVec& argv,
                                                unsigned& index,
                                                unsigned flags_to_include,
                                                unsigned flags_to_exclude) const;
    std::optional<ParsedArgument>
        internal_parse_one_arg(InputArgVec& argv,
                               unsigned& index,
                               std::function<bool(const Option&)> exclude_option) const;

    void parse_args(InputArgVec& argv,
                    unsigned& missing_arg_index,
                    unsigned& missing_arg_count,
                    std::function<void(std::expected<ParsedArgument, std::string>)> fn,
                    Visibility visibility_mask = Visibility()) const;

    void parse_args(InputArgVec& argv,
                    unsigned& missing_arg_index,
                    unsigned& missing_arg_count,
                    std::function<void(std::expected<ParsedArgument, std::string>)> fn,
                    unsigned flags_to_include,
                    unsigned flags_to_exclude) const;

    void parse_args(InputArgVec& argv,
                    OptSpecifier unknown,
                    std::function<void(std::expected<ParsedArgument, std::string>)> fn) const;

    void internal_parse_args(InputArgVec& argv,
                             unsigned& missing_arg_index,
                             unsigned& missing_arg_count,
                             std::function<void(std::expected<ParsedArgument, std::string>)> fn,
                             std::function<bool(const Option&)> exclude_option) const;
};
}  // namespace catter::opt
